---
title: "Soirée Recherche et validation"
# description: "* Summary of experience"
date: 2010-01-28T19:00:00+01:00
tags: [
    "",
]
event-date: 2019-11-25T21:12:27+01:00
draft: false
hideSpeaker: false
# intro: "* Introduction pour l'evenement"
place: "SupInfo" # emplacement de l'evenement
speakers: ["Emmanuel Bernard"] # Tableau avec les nom des speakers entre " et séparé par des , et doit être identique au titre du speaker enregistré !
# docs: [[]] # Tableau donnant les liens vers les documents de la soirée hors affiche - exemple : [["L'inauguration","http://toursjug.cloud.xwiki.com/xwiki/bin/download/Meetings/20080409/InaugurationToursJUG.pdf"], ["Unitils et Selenium","Unitils-Selenium.pdf"]]
# eventbrite: "" # Id de l'inscription (la partie de l'URL sr trouvant après https://www.eventbrite.fr/e/ )
# after: "" # Id (title urlizé d'un after) utilisé pour peupler la section after d'un evvent (exemple : apside-after-01)
---

#### Hibernate Search.

Trouver les données, vous valez mieux que ça La fonction recherche est un composant essentiel d'une application moderne. Retrouver des données devrait être efficace et rapide. Hibernate Search et Lucene fournissent une solution de recherche full-texte facile a utiliser et puissante. Après avoir présenté les avantages de la recherche full-texte, nous allons voir comment les moteurs de recherche font pour s'en sortir face aux erreurs de frappes et autre recherche approximative (notant ment via la recherche phonétique).


#### Bean Validation & Hibernate Validator

La validation des contraintes de données est un problème partagé par les niveaux logiques des applications (présentation, métier, persistance etc) et génère traditionnellement de la duplication. Bean Validation (JSR-303) standardise la validation dans la plate-forme Java. Cette session décrit Bean Validation et son implémentation Hibernate Validator en montrant comment les niveaux différents réutilisent la même déclaration de contrainte et valide de manière transparente les données de l'application.